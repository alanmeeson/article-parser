import layoutparser as lp


def non_max_suppression(layout: lp.Layout, threshold_iou: float = 0.5) -> lp.Layout:
    """
    Apply non-maximum suppression to avoid detecting too many
    overlapping bounding boxes for a given object.

    For any group of overlapping regions, the one with the highest score from the
    model is kept.

    Args:
        layout: (layoutparser.Layout) a Layout generated by layoutparser
        threshold_iou: (float) The overlap thresh for suppressing unnecessary boxes.
    Returns:
        A Layout with the overlapping regions removed.
    """

    # Declare the list of regions we're going to keep
    keep = []

    candidate_regions = layout.sort(key=lambda x: x.score)
    while candidate_regions:

        # extract and keep the region with highest score
        region = candidate_regions.pop()
        keep.append(region)

        # if we have any remaining candidate regions
        if candidate_regions:
            # then filter out the ones which significantly overlap with the current region
            # we do this with looking at the ratio of the intersection area over the union area.
            candidate_regions = [
                x
                for x in candidate_regions
                if (max(region.intersect(x).area, 0) / region.union(x).area) < threshold_iou
            ]

    return lp.Layout(keep)


def sub_section_suppression(layout: lp.Layout, tolerance: float = 0.1) -> lp.Layout:
    """
    Apply sub-section suppression to avoid detecting too many overlapping bounding
    boxes for a given object.  This specifically removes boxes which are (almost)
    entirely contained within another box.

    Args:
        layout: (layoutparser.Layout) a Layout generated by layoutparser
        tolerance: (float) how much of a box can be not within the larger box, and
            still count as overlapping.
    Returns:
        A Layout with the overlapping regions removed.
    """

    keep = []

    candidate_regions = layout.sort(key=lambda x: x.area)
    while candidate_regions:

        # extract and keep the region with largest area
        region = candidate_regions.pop()
        keep.append(region)

        # if we have any remaining candidate regions
        if candidate_regions:
            # We pad the larger region to allow a certain amount of tolerance for
            # being not quite entirely overlapping
            pad_x = (region.width * tolerance) / 2
            pad_y = (region.height * tolerance) / 2
            padded_region = region.pad(left=pad_x, right=pad_x, top=pad_y, bottom=pad_y)

            # then filter out the ones which are almost entirely inside the current region
            candidate_regions = [
                x
                for x in candidate_regions
                if not x.is_in(padded_region)
            ]

    return lp.Layout(keep)

